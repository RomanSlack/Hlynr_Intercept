"""
Comprehensive tests for coordinate transforms.

Tests deterministic ENU↔Unity transforms with round-trip validation,
axis/sign checks, and golden fixtures as required by the PRP.
"""

import pytest
import numpy as np
from typing import List, Tuple
import math

from ..transforms import CoordinateTransform, get_transform, validate_transform_version


class TestCoordinateTransforms:
    """Test coordinate transformation functionality."""
    
    def setup_method(self):
        """Set up test fixtures."""
        self.transform = CoordinateTransform("tfm_v1.0")
        self.tolerance = 1e-12
    
    def test_transform_version_validation(self):
        """Test transform version validation."""
        assert validate_transform_version("tfm_v1.0") is True
        assert validate_transform_version("invalid_version") is False
    
    def test_coordinate_system_mapping(self):
        """Test basic coordinate system mapping."""
        # Test cardinal directions
        
        # East (ENU X) → Unity X
        enu_east = [1.0, 0.0, 0.0]
        unity_pos = self.transform.enu_to_unity_position(enu_east)
        expected_unity = [1.0, 0.0, 0.0]  # Unity X
        np.testing.assert_allclose(unity_pos, expected_unity, atol=self.tolerance)
        
        # North (ENU Y) → Unity Z (with handedness flip)
        enu_north = [0.0, 1.0, 0.0]
        unity_pos = self.transform.enu_to_unity_position(enu_north)
        expected_unity = [0.0, 0.0, -1.0]  # Unity Z (flipped)
        np.testing.assert_allclose(unity_pos, expected_unity, atol=self.tolerance)
        
        # Up (ENU Z) → Unity Y
        enu_up = [0.0, 0.0, 1.0]
        unity_pos = self.transform.enu_to_unity_position(enu_up)
        expected_unity = [0.0, 1.0, 0.0]  # Unity Y
        np.testing.assert_allclose(unity_pos, expected_unity, atol=self.tolerance)
    
    def test_position_round_trip(self):
        """Test position round-trip transformations."""
        test_positions = [
            [0.0, 0.0, 0.0],        # Origin
            [1.0, 0.0, 0.0],        # East
            [0.0, 1.0, 0.0],        # North
            [0.0, 0.0, 1.0],        # Up
            [100.0, 200.0, 50.0],   # General case
            [-50.0, -75.0, 25.0],   # Negative coordinates
            [1000.0, 1500.0, 500.0] # Large coordinates
        ]
        
        for enu_pos in test_positions:
            # ENU → Unity → ENU
            unity_pos = self.transform.enu_to_unity_position(enu_pos)
            recovered_pos = self.transform.unity_to_enu_position(unity_pos)
            
            np.testing.assert_allclose(\n                recovered_pos, enu_pos, atol=self.tolerance,\n                err_msg=f\"Position round-trip failed for {enu_pos}\"\n            )\n    \n    def test_quaternion_round_trip(self):\n        \"\"\"Test quaternion round-trip transformations.\"\"\"\n        test_quaternions = [\n            [1.0, 0.0, 0.0, 0.0],        # Identity\n            [0.707, 0.707, 0.0, 0.0],    # 90° rotation about X\n            [0.707, 0.0, 0.707, 0.0],    # 90° rotation about Y\n            [0.707, 0.0, 0.0, 0.707],    # 90° rotation about Z\n            [0.995, 0.0, 0.1, 0.0],      # Small rotation about Y\n            [0.924, 0.0, 0.0, 0.383],    # 45° rotation about Z\n        ]\n        \n        for enu_quat in test_quaternions:\n            # Normalize input quaternion\n            enu_quat = self.transform._normalize_quaternion(enu_quat)\n            \n            # ENU → Unity → ENU\n            unity_quat = self.transform.enu_to_unity_quaternion(enu_quat)\n            recovered_quat = self.transform.unity_to_enu_quaternion(unity_quat)\n            \n            # Handle quaternion double cover (q and -q represent same rotation)\n            error1 = np.linalg.norm(np.array(recovered_quat) - np.array(enu_quat))\n            error2 = np.linalg.norm(np.array(recovered_quat) + np.array(enu_quat))\n            min_error = min(error1, error2)\n            \n            assert min_error < self.tolerance, \\\n                f\"Quaternion round-trip failed for {enu_quat}, error: {min_error}\"\n    \n    def test_velocity_transformations(self):\n        \"\"\"Test velocity vector transformations.\"\"\"\n        test_velocities = [\n            [0.0, 0.0, 0.0],        # Zero velocity\n            [10.0, 0.0, 0.0],       # East velocity\n            [0.0, 20.0, 0.0],       # North velocity\n            [0.0, 0.0, 5.0],        # Up velocity\n            [150.0, 10.0, -5.0],    # General case\n            [-50.0, -40.0, -10.0]   # Negative velocities\n        ]\n        \n        for enu_vel in test_velocities:\n            # ENU → Unity → ENU\n            unity_vel = self.transform.enu_to_unity_velocity(enu_vel)\n            recovered_vel = self.transform.unity_to_enu_velocity(unity_vel)\n            \n            np.testing.assert_allclose(\n                recovered_vel, enu_vel, atol=self.tolerance,\n                err_msg=f\"Velocity round-trip failed for {enu_vel}\"\n            )\n    \n    def test_angular_velocity_transformations(self):\n        \"\"\"Test angular velocity vector transformations.\"\"\"\n        test_angular_velocities = [\n            [0.0, 0.0, 0.0],        # Zero angular velocity\n            [0.1, 0.0, 0.0],        # Pitch rate\n            [0.0, 0.2, 0.0],        # Yaw rate\n            [0.0, 0.0, 0.05],       # Roll rate\n            [0.1, 0.2, 0.05],       # General case\n            [-0.5, -0.3, -0.1]      # Negative rates\n        ]\n        \n        for enu_angvel in test_angular_velocities:\n            # ENU → Unity → ENU\n            unity_angvel = self.transform.enu_to_unity_angular_velocity(enu_angvel)\n            recovered_angvel = self.transform.unity_to_enu_angular_velocity(unity_angvel)\n            \n            np.testing.assert_allclose(\n                recovered_angvel, enu_angvel, atol=self.tolerance,\n                err_msg=f\"Angular velocity round-trip failed for {enu_angvel}\"\n            )\n    \n    def test_state_transformation(self):\n        \"\"\"Test complete state transformations.\"\"\"\n        enu_state = {\n            'pos_m': [100.0, 200.0, 50.0],\n            'vel_mps': [150.0, 10.0, -5.0],\n            'quat_wxyz': [0.995, 0.0, 0.1, 0.0],\n            'ang_vel_radps': [0.1, 0.2, 0.05],\n            'fuel_frac': 0.75,  # Non-coordinate field\n            'status': 'active'   # Non-coordinate field\n        }\n        \n        # ENU → Unity → ENU\n        unity_state = self.transform.transform_state_enu_to_unity(enu_state)\n        recovered_state = self.transform.transform_state_unity_to_enu(unity_state)\n        \n        # Check coordinate fields\n        np.testing.assert_allclose(\n            recovered_state['pos_m'], enu_state['pos_m'], atol=self.tolerance\n        )\n        np.testing.assert_allclose(\n            recovered_state['vel_mps'], enu_state['vel_mps'], atol=self.tolerance\n        )\n        np.testing.assert_allclose(\n            recovered_state['ang_vel_radps'], enu_state['ang_vel_radps'], atol=self.tolerance\n        )\n        \n        # Check quaternion (handle double cover)\n        quat_error1 = np.linalg.norm(\n            np.array(recovered_state['quat_wxyz']) - np.array(enu_state['quat_wxyz'])\n        )\n        quat_error2 = np.linalg.norm(\n            np.array(recovered_state['quat_wxyz']) + np.array(enu_state['quat_wxyz'])\n        )\n        assert min(quat_error1, quat_error2) < self.tolerance\n        \n        # Check non-coordinate fields are preserved\n        assert recovered_state['fuel_frac'] == enu_state['fuel_frac']\n        assert recovered_state['status'] == enu_state['status']\n    \n    def test_quaternion_normalization(self):\n        \"\"\"Test quaternion normalization.\"\"\"\n        # Test various quaternions\n        test_quats = [\n            [1.0, 0.0, 0.0, 0.0],        # Already normalized\n            [2.0, 0.0, 0.0, 0.0],        # Needs normalization\n            [0.5, 0.5, 0.5, 0.5],        # Needs normalization\n            [1.414, 1.414, 0.0, 0.0],    # Needs normalization\n        ]\n        \n        for quat in test_quats:\n            normalized = self.transform._normalize_quaternion(quat)\n            \n            # Check magnitude is 1\n            magnitude = np.linalg.norm(normalized)\n            assert abs(magnitude - 1.0) < self.tolerance\n            \n            # Check direction is preserved (up to sign)\n            if np.linalg.norm(quat) > 0:\n                dot_product = np.dot(normalized, quat) / np.linalg.norm(quat)\n                assert abs(abs(dot_product) - 1.0) < self.tolerance\n    \n    def test_rotation_matrix_consistency(self):\n        \"\"\"Test quaternion ↔ rotation matrix conversions.\"\"\"\n        test_quaternions = [\n            [1.0, 0.0, 0.0, 0.0],        # Identity\n            [0.707, 0.707, 0.0, 0.0],    # 90° about X\n            [0.707, 0.0, 0.707, 0.0],    # 90° about Y\n            [0.707, 0.0, 0.0, 0.707],    # 90° about Z\n        ]\n        \n        for quat in test_quaternions:\n            # Quaternion → Matrix → Quaternion\n            matrix = self.transform._quaternion_to_matrix(quat)\n            recovered_quat = self.transform._matrix_to_quaternion(matrix)\n            \n            # Handle double cover\n            error1 = np.linalg.norm(np.array(recovered_quat) - np.array(quat))\n            error2 = np.linalg.norm(np.array(recovered_quat) + np.array(quat))\n            min_error = min(error1, error2)\n            \n            assert min_error < self.tolerance, \\\n                f\"Matrix conversion round-trip failed for {quat}\"\n            \n            # Check matrix properties\n            # Rotation matrices should be orthogonal\n            should_be_identity = matrix @ matrix.T\n            np.testing.assert_allclose(\n                should_be_identity, np.eye(3), atol=self.tolerance\n            )\n            \n            # Determinant should be +1 (not -1, which would be a reflection)\n            det = np.linalg.det(matrix)\n            assert abs(det - 1.0) < self.tolerance\n    \n    def test_axis_sign_consistency(self):\n        \"\"\"Test axis and sign consistency in transformations.\"\"\"\n        # Test specific axis mappings as required by PRP\n        \n        # ENU X (East) → Unity X\n        enu_x = [1.0, 0.0, 0.0]\n        unity_x = self.transform.enu_to_unity_position(enu_x)\n        assert np.allclose(unity_x, [1.0, 0.0, 0.0], atol=self.tolerance)\n        \n        # ENU Y (North) → Unity Z with handedness flip\n        enu_y = [0.0, 1.0, 0.0]\n        unity_z = self.transform.enu_to_unity_position(enu_y)\n        assert np.allclose(unity_z, [0.0, 0.0, -1.0], atol=self.tolerance)\n        \n        # ENU Z (Up) → Unity Y\n        enu_z = [0.0, 0.0, 1.0]\n        unity_y = self.transform.enu_to_unity_position(enu_z)\n        assert np.allclose(unity_y, [0.0, 1.0, 0.0], atol=self.tolerance)\n    \n    def test_transform_determinism(self):\n        \"\"\"Test transform determinism - same input should give identical output.\"\"\"\n        test_cases = [\n            ([100.0, 200.0, 50.0], [0.995, 0.0, 0.1, 0.0]),\n            ([0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0]),\n            ([-50.0, 75.0, 25.0], [0.707, 0.0, 0.707, 0.0])\n        ]\n        \n        for pos, quat in test_cases:\n            # Transform multiple times with same input\n            results_pos = []\n            results_quat = []\n            \n            for _ in range(10):\n                unity_pos = self.transform.enu_to_unity_position(pos)\n                unity_quat = self.transform.enu_to_unity_quaternion(quat)\n                results_pos.append(unity_pos)\n                results_quat.append(unity_quat)\n            \n            # All results should be identical\n            for i in range(1, len(results_pos)):\n                np.testing.assert_array_equal(\n                    results_pos[0], results_pos[i],\n                    err_msg=\"Position transform not deterministic\"\n                )\n                np.testing.assert_array_equal(\n                    results_quat[0], results_quat[i],\n                    err_msg=\"Quaternion transform not deterministic\"\n                )\n    \n    def test_golden_fixtures(self):\n        \"\"\"Test against golden reference values.\"\"\"\n        # Golden test cases with known correct outputs\n        golden_cases = [\n            {\n                'enu_pos': [100.0, 200.0, 50.0],\n                'unity_pos': [100.0, 50.0, -200.0],  # [x, z, -y]\n                'description': 'General position'\n            },\n            {\n                'enu_pos': [1.0, 0.0, 0.0],\n                'unity_pos': [1.0, 0.0, 0.0],  # East unchanged\n                'description': 'East direction'\n            },\n            {\n                'enu_pos': [0.0, 1.0, 0.0],\n                'unity_pos': [0.0, 0.0, -1.0],  # North with flip\n                'description': 'North direction with handedness flip'\n            },\n            {\n                'enu_pos': [0.0, 0.0, 1.0],\n                'unity_pos': [0.0, 1.0, 0.0],  # Up direction\n                'description': 'Up direction'\n            }\n        ]\n        \n        for case in golden_cases:\n            result = self.transform.enu_to_unity_position(case['enu_pos'])\n            np.testing.assert_allclose(\n                result, case['unity_pos'], atol=self.tolerance,\n                err_msg=f\"Golden test failed: {case['description']}\"\n            )\n    \n    def test_edge_cases(self):\n        \"\"\"Test edge cases and error conditions.\"\"\"\n        # Test invalid dimensions\n        with pytest.raises(ValueError):\n            self.transform.enu_to_unity_position([1.0, 2.0])  # 2D instead of 3D\n        \n        with pytest.raises(ValueError):\n            self.transform.enu_to_unity_quaternion([1.0, 0.0, 0.0])  # 3D instead of 4D\n        \n        # Test zero quaternion\n        with pytest.raises(ValueError):\n            self.transform._normalize_quaternion([0.0, 0.0, 0.0, 0.0])\n        \n        # Test very small quaternion (should work after normalization)\n        small_quat = [1e-10, 1e-10, 1e-10, 1e-10]\n        normalized = self.transform._normalize_quaternion(small_quat)\n        assert abs(np.linalg.norm(normalized) - 1.0) < self.tolerance\n    \n    def test_global_transform_instance(self):\n        \"\"\"Test global transform instance management.\"\"\"\n        transform1 = get_transform(\"tfm_v1.0\")\n        transform2 = get_transform(\"tfm_v1.0\")\n        \n        # Should return same instance\n        assert transform1 is transform2\n        \n        # Should have correct version\n        assert transform1.version == \"tfm_v1.0\"\n    \n    def test_performance_benchmarks(self):\n        \"\"\"Test transform performance for monitoring.\"\"\"\n        import time\n        \n        # Test data\n        positions = [[100.0 * i, 200.0 * i, 50.0 * i] for i in range(1000)]\n        quaternions = [[0.995, 0.01 * i, 0.1, 0.0] for i in range(1000)]\n        \n        # Benchmark position transforms\n        start_time = time.perf_counter()\n        for pos in positions:\n            self.transform.enu_to_unity_position(pos)\n        pos_time = time.perf_counter() - start_time\n        \n        # Benchmark quaternion transforms\n        start_time = time.perf_counter()\n        for quat in quaternions:\n            self.transform.enu_to_unity_quaternion(quat)\n        quat_time = time.perf_counter() - start_time\n        \n        # Basic performance check (should be fast)\n        assert pos_time < 1.0, f\"Position transforms too slow: {pos_time:.3f}s\"\n        assert quat_time < 2.0, f\"Quaternion transforms too slow: {quat_time:.3f}s\"\n        \n        print(f\"Position transform rate: {len(positions) / pos_time:.0f} ops/sec\")\n        print(f\"Quaternion transform rate: {len(quaternions) / quat_time:.0f} ops/sec\")\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])