"""
Tests for VecNormalize determinism and golden vector validation.

Tests that the same input produces byte-identical outputs and validates
known golden vectors produce expected actions.
"""

import pytest
import numpy as np
import tempfile
import pickle
from pathlib import Path
from unittest.mock import MagicMock, patch
import json

from ..normalize import (
    VecNormalizeManager, VecNormalizeInfo, get_vecnorm_manager,
    load_vecnormalize_by_id, register_vecnormalize_from_checkpoint
)


class TestVecNormalizeDeterminism:
    """Test VecNormalize deterministic behavior."""
    
    def setup_method(self):
        """Set up test fixtures."""
        self.temp_dir = tempfile.mkdtemp()
        self.manager = VecNormalizeManager(self.temp_dir)
        
        # Create mock VecNormalize
        self.mock_vecnorm = MagicMock()
        self.mock_vecnorm.obs_rms = MagicMock()
        self.mock_vecnorm.obs_rms.mean = np.array([0.0, 0.0, 1.0, 1.0])
        self.mock_vecnorm.obs_rms.var = np.array([1.0, 1.0, 0.5, 0.5])
        self.mock_vecnorm.obs_rms.count = 10000
        self.mock_vecnorm.clip_obs = 10.0
        self.mock_vecnorm.observation_space = MagicMock()
        self.mock_vecnorm.observation_space.shape = (4,)
        
        # Mock environment
        self.mock_env = MagicMock()
        self.mock_env.observation_space = MagicMock()
        self.mock_env.observation_space.shape = (4,)
    
    def test_stats_id_generation(self):
        """Test deterministic statistics ID generation."""\n        # Same inputs should generate same ID\n        checkpoint_path = \"/path/to/checkpoint\"\n        obs_version = \"obs_v1.0\"\n        \n        id1 = self.manager._generate_stats_id(checkpoint_path, obs_version)\n        id2 = self.manager._generate_stats_id(checkpoint_path, obs_version)\n        \n        assert id1 == id2\n        \n        # Different inputs should generate different IDs\n        id3 = self.manager._generate_stats_id(\"/different/path\", obs_version)\n        id4 = self.manager._generate_stats_id(checkpoint_path, \"obs_v1.1\")\n        \n        assert id1 != id3\n        assert id1 != id4\n    \n    def test_vecnormalize_registration(self):\n        \"\"\"Test VecNormalize registration and retrieval.\"\"\"\n        # Register VecNormalize\n        with patch('stable_baselines3.common.vec_env.VecNormalize') as mock_class:\n            mock_class.return_value = self.mock_vecnorm\n            \n            stats_id = self.manager.register_vecnormalize(\n                vecnorm=self.mock_vecnorm,\n                checkpoint_path=\"/test/checkpoint\",\n                obs_version=\"obs_v1.0\",\n                description=\"Test VecNormalize\"\n            )\n        \n        # Should be in registry\n        assert stats_id in self.manager.registry\n        registry_entry = self.manager.registry[stats_id]\n        \n        assert registry_entry['obs_version'] == \"obs_v1.0\"\n        assert registry_entry['description'] == \"Test VecNormalize\"\n        assert len(registry_entry['obs_mean']) == 4\n        assert len(registry_entry['obs_var']) == 4\n        assert registry_entry['obs_count'] == 10000\n    \n    def test_deterministic_loading(self):\n        \"\"\"Test that loading same stats ID gives identical results.\"\"\"\n        # Register a VecNormalize\n        with patch('stable_baselines3.common.vec_env.VecNormalize') as mock_class:\n            mock_instance = MagicMock()\n            mock_instance.obs_rms = self.mock_vecnorm.obs_rms\n            mock_class.return_value = mock_instance\n            \n            stats_id = self.manager.register_vecnormalize(\n                vecnorm=self.mock_vecnorm,\n                checkpoint_path=\"/test/checkpoint\",\n                obs_version=\"obs_v1.0\"\n            )\n        \n        # Load multiple times\n        with patch('stable_baselines3.common.vec_env.VecNormalize.load') as mock_load:\n            mock_load.return_value = mock_instance\n            \n            vecnorm1, info1 = self.manager.load_vecnormalize(stats_id, self.mock_env)\n            vecnorm2, info2 = self.manager.load_vecnormalize(stats_id, self.mock_env)\n            \n            # Info should be identical\n            assert info1.stats_id == info2.stats_id\n            assert info1.obs_version == info2.obs_version\n            assert info1.obs_mean == info2.obs_mean\n            assert info1.obs_var == info2.obs_var\n            assert info1.obs_count == info2.obs_count\n    \n    def test_golden_vector_validation(self):\n        \"\"\"Test golden vector â†’ known action validation.\"\"\"\n        # Set up mock VecNormalize with known parameters\n        mock_vecnorm = MagicMock()\n        mock_vecnorm.obs_rms.mean = np.array([0.0, 0.0, 0.0, 0.0])\n        mock_vecnorm.obs_rms.var = np.array([1.0, 1.0, 1.0, 1.0])\n        mock_vecnorm.clip_obs = 10.0\n        \n        # Golden test vectors (known input â†’ expected output)\n        golden_cases = [\n            {\n                'name': 'zero_input',\n                'observation': np.array([0.0, 0.0, 0.0, 0.0]),\n                'expected_normalized': np.array([0.0, 0.0, 0.0, 0.0]),\n                'description': 'Zero input should remain zero'\n            },\n            {\n                'name': 'unit_input',\n                'observation': np.array([1.0, 1.0, 1.0, 1.0]),\n                'expected_normalized': np.array([1.0, 1.0, 1.0, 1.0]),\n                'description': 'Unit input with unit variance'\n            },\n            {\n                'name': 'negative_input',\n                'observation': np.array([-1.0, -1.0, -1.0, -1.0]),\n                'expected_normalized': np.array([-1.0, -1.0, -1.0, -1.0]),\n                'description': 'Negative input symmetry'\n            }\n        ]\n        \n        for case in golden_cases:\n            # Manually apply VecNormalize transformation\n            obs = case['observation']\n            mean = mock_vecnorm.obs_rms.mean\n            var = mock_vecnorm.obs_rms.var\n            \n            normalized = (obs - mean) / np.sqrt(var + 1e-8)\n            clipped = np.clip(normalized, -mock_vecnorm.clip_obs, mock_vecnorm.clip_obs)\n            \n            np.testing.assert_allclose(\n                clipped, case['expected_normalized'], atol=1e-6,\n                err_msg=f\"Golden test failed: {case['description']}\"\n            )\n    \n    def test_clip_fraction_computation(self):\n        \"\"\"Test observation clipping fraction computation.\"\"\"\n        # Set up VecNormalize with known parameters\n        self.manager.current_vecnorm = self.mock_vecnorm\n        self.manager.current_vecnorm.obs_rms.mean = np.array([0.0, 0.0, 0.0, 0.0])\n        self.manager.current_vecnorm.obs_rms.var = np.array([1.0, 1.0, 1.0, 1.0])\n        self.manager.current_vecnorm.clip_obs = 2.0\n        \n        # Test observations that will cause clipping\n        observations = np.array([\n            [0.0, 0.0, 0.0, 0.0],      # No clipping\n            [1.0, 1.0, 1.0, 1.0],      # No clipping\n            [3.0, 3.0, 3.0, 3.0],      # High clipping\n            [-3.0, -3.0, -3.0, -3.0],  # Low clipping\n            [3.0, -3.0, 1.0, 0.0],     # Mixed clipping\n        ])\n        \n        clip_fractions = self.manager.compute_clip_fractions(observations)\n        \n        # Should have both low and high clipping\n        assert clip_fractions['low'] > 0.0\n        assert clip_fractions['high'] > 0.0\n        assert 0.0 <= clip_fractions['low'] <= 1.0\n        assert 0.0 <= clip_fractions['high'] <= 1.0\n    \n    def test_observation_shape_validation(self):\n        \"\"\"Test observation shape validation.\"\"\"\n        # Set up current VecNormalize\n        self.manager.current_vecnorm = self.mock_vecnorm\n        \n        # Valid shape\n        valid_obs = np.random.randn(10, 4)  # Batch of 10 observations\n        assert self.manager.validate_observation_shape(valid_obs) is True\n        \n        # Invalid shape\n        invalid_obs = np.random.randn(10, 5)  # Wrong observation dimension\n        assert self.manager.validate_observation_shape(invalid_obs) is False\n        \n        # No VecNormalize loaded (should pass)\n        self.manager.current_vecnorm = None\n        assert self.manager.validate_observation_shape(invalid_obs) is True\n    \n    def test_registry_persistence(self):\n        \"\"\"Test registry save/load persistence.\"\"\"\n        # Register a VecNormalize\n        with patch('stable_baselines3.common.vec_env.VecNormalize') as mock_class:\n            mock_class.return_value = self.mock_vecnorm\n            \n            stats_id = self.manager.register_vecnormalize(\n                vecnorm=self.mock_vecnorm,\n                checkpoint_path=\"/test/checkpoint\",\n                obs_version=\"obs_v1.0\",\n                description=\"Test persistence\"\n            )\n        \n        # Create new manager (should load existing registry)\n        new_manager = VecNormalizeManager(self.temp_dir)\n        \n        # Should have the registered stats\n        assert stats_id in new_manager.registry\n        assert new_manager.registry[stats_id]['description'] == \"Test persistence\"\n    \n    def test_version_compatibility(self):\n        \"\"\"Test observation version compatibility checking.\"\"\"\n        # Register VecNormalize with specific obs version\n        with patch('stable_baselines3.common.vec_env.VecNormalize') as mock_class:\n            mock_class.return_value = self.mock_vecnorm\n            \n            stats_id = self.manager.register_vecnormalize(\n                vecnorm=self.mock_vecnorm,\n                checkpoint_path=\"/test/checkpoint\",\n                obs_version=\"obs_v1.0\"\n            )\n        \n        # Load with compatible version\n        with patch('stable_baselines3.common.vec_env.VecNormalize.load') as mock_load:\n            mock_load.return_value = self.mock_vecnorm\n            \n            vecnorm, info = self.manager.load_vecnormalize(\n                stats_id, self.mock_env, obs_version=\"obs_v1.0\"\n            )\n            assert info.obs_version == \"obs_v1.0\"\n        \n        # Load with incompatible version (should raise)\n        with pytest.raises(ValueError, match=\"Observation version mismatch\"):\n            self.manager.load_vecnormalize(\n                stats_id, self.mock_env, obs_version=\"obs_v2.0\"\n            )\n    \n    def test_legacy_file_import(self):\n        \"\"\"Test importing from legacy vec_normalize.pkl files.\"\"\"\n        # Create a temporary legacy file\n        legacy_file = Path(self.temp_dir) / \"vec_normalize.pkl\"\n        \n        # Mock VecNormalize object to save\n        with open(legacy_file, 'wb') as f:\n            pickle.dump({'mock': 'vecnormalize'}, f)\n        \n        with patch('stable_baselines3.common.vec_env.VecNormalize.load') as mock_load:\n            mock_load.return_value = self.mock_vecnorm\n            \n            stats_id = self.manager.create_from_legacy_file(\n                legacy_path=str(legacy_file),\n                env=self.mock_env,\n                obs_version=\"obs_v1.0\",\n                description=\"Imported from legacy\"\n            )\n        \n        # Should be registered\n        assert stats_id in self.manager.registry\n        assert self.manager.registry[stats_id]['description'] == \"Imported from legacy\"\n    \n    def test_statistics_summary(self):\n        \"\"\"Test registry statistics summary.\"\"\"\n        # Register multiple VecNormalizes\n        with patch('stable_baselines3.common.vec_env.VecNormalize') as mock_class:\n            mock_class.return_value = self.mock_vecnorm\n            \n            id1 = self.manager.register_vecnormalize(\n                vecnorm=self.mock_vecnorm, checkpoint_path=\"/test1\", obs_version=\"obs_v1.0\"\n            )\n            id2 = self.manager.register_vecnormalize(\n                vecnorm=self.mock_vecnorm, checkpoint_path=\"/test2\", obs_version=\"obs_v1.1\"\n            )\n        \n        summary = self.manager.get_registry_summary()\n        \n        assert summary['total_stats'] == 2\n        assert 'obs_v1.0' in summary['obs_versions']\n        assert 'obs_v1.1' in summary['obs_versions']\n        assert summary['current_loaded'] is None  # None loaded initially\n    \n    def test_byte_identical_normalization(self):\n        \"\"\"Test that identical inputs produce byte-identical outputs.\"\"\"\n        # Set up deterministic VecNormalize\n        mock_vecnorm = MagicMock()\n        mock_vecnorm.obs_rms.mean = np.array([1.0, 2.0, 3.0, 4.0])\n        mock_vecnorm.obs_rms.var = np.array([0.1, 0.2, 0.3, 0.4])\n        mock_vecnorm.clip_obs = 10.0\n        \n        self.manager.current_vecnorm = mock_vecnorm\n        \n        # Same input multiple times\n        test_obs = np.array([[1.5, 2.5, 3.5, 4.5]])\n        \n        results = []\n        for _ in range(10):\n            clip_fractions = self.manager.compute_clip_fractions(test_obs)\n            # Convert to bytes for exact comparison\n            result_bytes = json.dumps(clip_fractions, sort_keys=True).encode()\n            results.append(result_bytes)\n        \n        # All results should be byte-identical\n        for i in range(1, len(results)):\n            assert results[0] == results[i], \"Normalization not deterministic\"\n    \n    def test_concurrent_access_safety(self):\n        \"\"\"Test thread safety of VecNormalize operations.\"\"\"\n        import threading\n        \n        # Register VecNormalize\n        with patch('stable_baselines3.common.vec_env.VecNormalize') as mock_class:\n            mock_class.return_value = self.mock_vecnorm\n            \n            stats_id = self.manager.register_vecnormalize(\n                vecnorm=self.mock_vecnorm,\n                checkpoint_path=\"/test/checkpoint\",\n                obs_version=\"obs_v1.0\"\n            )\n        \n        results = []\n        errors = []\n        \n        def load_vecnormalize():\n            try:\n                with patch('stable_baselines3.common.vec_env.VecNormalize.load') as mock_load:\n                    mock_load.return_value = self.mock_vecnorm\n                    vecnorm, info = self.manager.load_vecnormalize(stats_id, self.mock_env)\n                    results.append(info.stats_id)\n            except Exception as e:\n                errors.append(e)\n        \n        # Create multiple threads\n        threads = [threading.Thread(target=load_vecnormalize) for _ in range(10)]\n        \n        # Start all threads\n        for thread in threads:\n            thread.start()\n        \n        # Wait for completion\n        for thread in threads:\n            thread.join()\n        \n        # Should have no errors and all same stats_id\n        assert len(errors) == 0, f\"Concurrent access errors: {errors}\"\n        assert len(results) == 10\n        assert all(r == stats_id for r in results)\n    \n    def test_error_handling(self):\n        \"\"\"Test error handling in edge cases.\"\"\"\n        # Load non-existent stats ID\n        with pytest.raises(ValueError, match=\"VecNormalize stats ID not found\"):\n            self.manager.load_vecnormalize(\"nonexistent\", self.mock_env)\n        \n        # Import non-existent legacy file\n        with pytest.raises(FileNotFoundError):\n            self.manager.create_from_legacy_file(\n                \"/nonexistent/file.pkl\", self.mock_env, \"obs_v1.0\"\n            )\n        \n        # Compute clip fractions without VecNormalize\n        self.manager.current_vecnorm = None\n        clip_fractions = self.manager.compute_clip_fractions(np.array([[1, 2, 3, 4]]))\n        assert clip_fractions == {'low': 0.0, 'high': 0.0}\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])