#!/usr/bin/env python3
"""
Quick episode plotting helper for Phase 4 RL diagnostics.

This script provides a simple command-line interface for visualizing
episode data from JSON files generated by the diagnostics system.
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Dict, Any, List, Optional

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.animation import FuncAnimation


def load_episode_data(json_path: str) -> Dict[str, Any]:
    """
    Load episode data from JSON file.
    
    Args:
        json_path: Path to JSON file containing episode data
        
    Returns:
        Episode data dictionary
    """
    with open(json_path, 'r') as f:
        data = json.load(f)
    return data


def plot_trajectories(episode_data: Dict[str, Any], output_path: Optional[str] = None):
    """
    Plot missile and interceptor trajectories.
    
    Args:
        episode_data: Episode data from JSON file
        output_path: Optional path to save plot
    """
    metrics = episode_data.get('metrics', {})
    missile_trajectories = metrics.get('missile_trajectories', [])
    interceptor_trajectories = metrics.get('interceptor_trajectories', [])
    
    if not missile_trajectories and not interceptor_trajectories:
        print("Warning: No trajectory data found in episode")
        return
    
    plt.figure(figsize=(12, 8))
    
    # Plot missile trajectories
    for i, trajectory in enumerate(missile_trajectories):
        if trajectory:
            x_coords = [point[0] for point in trajectory]
            y_coords = [point[1] for point in trajectory]
            plt.plot(x_coords, y_coords, 'r-', linewidth=2, 
                    label=f'Missile {i}' if i == 0 else '', alpha=0.8)
            # Mark start and end points
            plt.scatter(x_coords[0], y_coords[0], c='red', s=100, marker='o', 
                       edgecolors='black', zorder=5)
            plt.scatter(x_coords[-1], y_coords[-1], c='red', s=100, marker='X', 
                       edgecolors='black', zorder=5)
    
    # Plot interceptor trajectories  
    for i, trajectory in enumerate(interceptor_trajectories):
        if trajectory:
            x_coords = [point[0] for point in trajectory]
            y_coords = [point[1] for point in trajectory]
            plt.plot(x_coords, y_coords, 'b-', linewidth=2,
                    label=f'Interceptor {i}' if i == 0 else '', alpha=0.8)
            # Mark start and end points
            plt.scatter(x_coords[0], y_coords[0], c='blue', s=100, marker='o',
                       edgecolors='black', zorder=5)
            plt.scatter(x_coords[-1], y_coords[-1], c='blue', s=100, marker='s',
                       edgecolors='black', zorder=5)
    
    plt.grid(True, alpha=0.3)
    plt.xlabel('X Position')
    plt.ylabel('Y Position')
    plt.title(f'Episode Trajectories - Total Reward: {metrics.get("total_reward", "N/A"):.2f}')
    plt.legend()
    plt.axis('equal')
    
    if output_path:
        plt.savefig(output_path, dpi=300, bbox_inches='tight')
        print(f"Trajectory plot saved to: {output_path}")
    else:
        plt.show()


def plot_reward_over_time(episode_data: Dict[str, Any], output_path: Optional[str] = None):
    """
    Plot reward evolution over episode steps.
    
    Args:
        episode_data: Episode data from JSON file
        output_path: Optional path to save plot
    """
    step_data = episode_data.get('step_data', [])
    
    if not step_data:
        print("Warning: No step data found in episode")
        return
    
    steps = [step['step'] for step in step_data]
    rewards = [step['reward'] for step in step_data]
    cumulative_rewards = np.cumsum(rewards)
    
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))
    
    # Step rewards
    ax1.plot(steps, rewards, 'g-', linewidth=1, alpha=0.7)
    ax1.fill_between(steps, rewards, alpha=0.3, color='green')
    ax1.set_xlabel('Step')
    ax1.set_ylabel('Step Reward')
    ax1.set_title('Step Rewards Over Time')
    ax1.grid(True, alpha=0.3)
    
    # Cumulative rewards
    ax2.plot(steps, cumulative_rewards, 'b-', linewidth=2)
    ax2.set_xlabel('Step')
    ax2.set_ylabel('Cumulative Reward')
    ax2.set_title(f'Cumulative Reward - Final: {cumulative_rewards[-1]:.2f}')
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    if output_path:
        plt.savefig(output_path, dpi=300, bbox_inches='tight')
        print(f"Reward plot saved to: {output_path}")
    else:
        plt.show()


def plot_distances(episode_data: Dict[str, Any], output_path: Optional[str] = None):
    """
    Plot minimum interception distances over time.
    
    Args:
        episode_data: Episode data from JSON file  
        output_path: Optional path to save plot
    """
    metrics = episode_data.get('metrics', {})
    min_distances = metrics.get('min_interception_distances', [])
    
    if not min_distances:
        print("Warning: No distance data found in episode")
        return
    
    steps = list(range(len(min_distances)))
    
    plt.figure(figsize=(12, 6))
    plt.plot(steps, min_distances, 'r-', linewidth=2, label='Min Distance')
    
    # Add interception threshold line
    threshold = 50.0  # Default interception threshold
    plt.axhline(y=threshold, color='orange', linestyle='--', linewidth=2, 
                label=f'Interception Threshold ({threshold})')
    
    # Highlight successful interceptions
    successful_points = [(i, d) for i, d in enumerate(min_distances) if d <= threshold]
    if successful_points:
        success_steps, success_distances = zip(*successful_points)
        plt.scatter(success_steps, success_distances, c='green', s=100, 
                   label='Successful Interceptions', zorder=5)
    
    plt.fill_between(steps, min_distances, alpha=0.3, color='red')
    plt.xlabel('Step')
    plt.ylabel('Minimum Distance')
    plt.title(f'Interception Distance Over Time - Closest Approach: {min(min_distances):.2f}')
    plt.legend()
    plt.grid(True, alpha=0.3)
    
    if output_path:
        plt.savefig(output_path, dpi=300, bbox_inches='tight')
        print(f"Distance plot saved to: {output_path}")
    else:
        plt.show()


def plot_summary_dashboard(episode_data: Dict[str, Any], output_path: Optional[str] = None):
    """
    Create a comprehensive dashboard with all key metrics.
    
    Args:
        episode_data: Episode data from JSON file
        output_path: Optional path to save plot
    """
    metrics = episode_data.get('metrics', {})
    step_data = episode_data.get('step_data', [])
    
    fig = plt.figure(figsize=(16, 12))
    
    # Create subplot layout
    gs = fig.add_gridspec(3, 2, height_ratios=[2, 1, 1], hspace=0.3, wspace=0.3)
    
    # 1. Trajectories (top, full width)
    ax1 = fig.add_subplot(gs[0, :])
    missile_trajectories = metrics.get('missile_trajectories', [])
    interceptor_trajectories = metrics.get('interceptor_trajectories', [])
    
    for i, trajectory in enumerate(missile_trajectories):
        if trajectory:
            x_coords = [point[0] for point in trajectory]
            y_coords = [point[1] for point in trajectory]
            ax1.plot(x_coords, y_coords, 'r-', linewidth=2, alpha=0.8)
            ax1.scatter(x_coords[0], y_coords[0], c='red', s=100, marker='o')
            ax1.scatter(x_coords[-1], y_coords[-1], c='red', s=100, marker='X')
    
    for i, trajectory in enumerate(interceptor_trajectories):
        if trajectory:
            x_coords = [point[0] for point in trajectory]
            y_coords = [point[1] for point in trajectory]
            ax1.plot(x_coords, y_coords, 'b-', linewidth=2, alpha=0.8)
            ax1.scatter(x_coords[0], y_coords[0], c='blue', s=100, marker='o')
            ax1.scatter(x_coords[-1], y_coords[-1], c='blue', s=100, marker='s')
    
    ax1.set_title('Trajectories')
    ax1.grid(True, alpha=0.3)
    ax1.axis('equal')
    
    # 2. Cumulative reward (bottom left)
    ax2 = fig.add_subplot(gs[1, 0])
    if step_data:
        steps = [step['step'] for step in step_data]
        rewards = [step['reward'] for step in step_data]
        cumulative_rewards = np.cumsum(rewards)
        ax2.plot(steps, cumulative_rewards, 'b-', linewidth=2)
        ax2.set_title(f'Cumulative Reward: {cumulative_rewards[-1]:.2f}')
    ax2.grid(True, alpha=0.3)
    
    # 3. Distances (bottom right)
    ax3 = fig.add_subplot(gs[1, 1])
    min_distances = metrics.get('min_interception_distances', [])
    if min_distances:
        steps = list(range(len(min_distances)))
        ax3.plot(steps, min_distances, 'r-', linewidth=2)
        ax3.axhline(y=50.0, color='orange', linestyle='--')
        ax3.set_title(f'Min Distance: {min(min_distances):.2f}')
    ax3.grid(True, alpha=0.3)
    
    # 4. Episode summary (bottom, full width)
    ax4 = fig.add_subplot(gs[2, :])
    ax4.axis('off')
    
    # Create summary text
    summary_text = f"""
    Episode Summary:
    • Total Reward: {metrics.get('total_reward', 'N/A'):.2f}
    • Episode Length: {metrics.get('total_steps', 'N/A')} steps
    • Success: {'YES' if metrics.get('successful_interception', False) else 'NO'}
    • Closest Approach: {metrics.get('closest_approach', 'N/A'):.2f}
    • Efficiency Score: {metrics.get('efficiency_score', 'N/A'):.3f}
    • Fuel Usage: Total {metrics.get('fuel_usage', {}).get('total_interceptor_fuel', 'N/A'):.2f}
    """
    
    ax4.text(0.1, 0.5, summary_text, fontsize=12, verticalalignment='center',
             bbox=dict(boxstyle="round,pad=0.3", facecolor="lightgray"))
    
    plt.suptitle(f'Episode Analysis Dashboard', fontsize=16)
    
    if output_path:
        plt.savefig(output_path, dpi=300, bbox_inches='tight')
        print(f"Dashboard saved to: {output_path}")
    else:
        plt.show()


def main():
    """Main entry point for episode plotting script."""
    parser = argparse.ArgumentParser(description='Plot Episode Data from Phase 4 RL Diagnostics')
    
    parser.add_argument('json_file', help='Path to episode JSON file')
    
    parser.add_argument('--plot-type', 
                       choices=['trajectories', 'rewards', 'distances', 'dashboard', 'all'],
                       default='dashboard',
                       help='Type of plot to generate')
    
    parser.add_argument('--output', '-o',
                       help='Output file path (if not specified, plots are displayed)')
    
    parser.add_argument('--output-dir',
                       help='Output directory for saving plots (when using --plot-type all)')
    
    args = parser.parse_args()
    
    # Validate input file
    json_path = Path(args.json_file)
    if not json_path.exists():
        print(f"Error: JSON file not found: {json_path}")
        sys.exit(1)
    
    # Load episode data
    try:
        episode_data = load_episode_data(json_path)
        print(f"Loaded episode data from: {json_path}")
    except Exception as e:
        print(f"Error loading JSON file: {e}")
        sys.exit(1)
    
    # Generate plots based on type
    if args.plot_type == 'trajectories':
        plot_trajectories(episode_data, args.output)
    elif args.plot_type == 'rewards':
        plot_reward_over_time(episode_data, args.output)
    elif args.plot_type == 'distances':
        plot_distances(episode_data, args.output)
    elif args.plot_type == 'dashboard':
        plot_summary_dashboard(episode_data, args.output)
    elif args.plot_type == 'all':
        # Generate all plot types
        output_dir = Path(args.output_dir) if args.output_dir else json_path.parent
        output_dir.mkdir(exist_ok=True)
        
        base_name = json_path.stem
        plot_trajectories(episode_data, output_dir / f"{base_name}_trajectories.png")
        plot_reward_over_time(episode_data, output_dir / f"{base_name}_rewards.png")  
        plot_distances(episode_data, output_dir / f"{base_name}_distances.png")
        plot_summary_dashboard(episode_data, output_dir / f"{base_name}_dashboard.png")
        
        print(f"All plots saved to: {output_dir}")


if __name__ == '__main__':
    main()